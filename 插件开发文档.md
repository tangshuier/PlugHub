# WPF插件工具箱 - 插件开发文档

## 1. 简介

### 1.1 工具箱概述

WPF插件工具箱是一个基于WPF的插件管理系统，支持热插拔插件、插件依赖管理、插件UI多标签页和调试功能。本文档将指导开发者如何开发符合规范的插件。

### 1.2 核心功能

- ✅ 热插拔插件
- ✅ 插件依赖管理（必要/非必要依赖）
- ✅ 插件UI多标签页支持
- ✅ 专门的调试窗口
- ✅ 插件重新加载功能
- ✅ 完整的API支持（文件操作、窗口创建、日志记录等）
- ✅ 插件生命周期管理

## 2. 开发环境搭建

### 2.1 必要条件

| 组件 | 版本要求 |
|------|----------|
| .NET SDK | .NET 9.0 或更高版本 |
| 开发工具 | Visual Studio 2022 或更高版本 |
| 框架 | WPF |

### 2.2 创建插件项目

1. 打开Visual Studio，创建一个新的**类库项目**（.NET 9.0-windows）
2. 添加对WPF工具箱核心API的引用：
   - 引用 `WPFPluginToolbox.Core.dll`

### 2.3 项目结构

```
MyPlugin/
├── MyPlugin.csproj
├── Properties/
│   └── AssemblyInfo.cs
└── MyPlugin.cs (插件主类)
```

## 3. 插件类型和接口

### 3.1 插件类型

| 类型 | 说明 | 接口 |
|------|------|------|
| **Plugin** | 独立运行的插件，有独立页面和功能 | `IPlugin` |
| **Dependency** | 提供API的依赖组件，为插件提供额外功能 | `IDependency` |

### 3.2 核心接口

#### 3.2.1 IPlugin 接口

```csharp
public interface IPlugin
{
    // 插件基本信息
    string Id { get; }
    string Name { get; }
    string Description { get; }
    string Version { get; }
    PluginType Type { get; }

    // 生命周期方法
    void Initialize(IPluginAPI pluginApi);
    void Activate();
    void Deactivate();
    void Dispose();

    // UI方法
    UserControl GetMainView();
}
```

#### 3.2.2 IDependency 接口

```csharp
public interface IDependency
{
    // 依赖基本信息
    string Id { get; }
    string Name { get; }
    string Description { get; }
    string Version { get; }

    // 生命周期方法
    void Initialize();
    void Dispose();
}
```

#### 3.2.3 IPluginAPI 接口

```csharp
public interface IPluginAPI
{
    // 基础信息
    string PluginId { get; }
    string PluginName { get; }
    string PluginPath { get; }

    // 日志API
    void Debug(string message, object data = null);
    void Info(string message, object data = null);
    void Warn(string message, object data = null);
    void Error(string message, Exception exception = null);

    // 文件操作API
    Task<string> ReadFileAsync(string path);
    Task WriteFileAsync(string path, string content);
    Task CreateFileAsync(string path);
    bool FileExists(string path);
    Task DeleteFileAsync(string path);
    Task CreateDirectoryAsync(string path);
    bool DirectoryExists(string path);
    IEnumerable<string> SearchFiles(string directory, string pattern, bool recursive = false);

    // 窗口操作API
    Window CreateWindow(string title, UserControl content, bool isModal = false);
    void ShowWindow(Window window);
    void CloseWindow(Window window);

    // 插件操作API
    IDependency GetDependency(string pluginId);
    bool HasDependency(string pluginId);
}
```

## 4. 插件开发流程

### 4.1 1. 创建插件类

创建一个实现 `IPlugin` 或 `IDependency` 接口的类：

```csharp
using System.Windows.Controls;
using WPFPluginToolbox.Core;

public class MyPlugin : IPlugin
{
    // 插件基本信息
    public string Id { get; } = "MyPlugin";
    public string Name { get; } = "我的插件";
    public string Description { get; } = "这是一个示例插件";
    public string Version { get; } = "1.0.0";
    public PluginType Type { get; } = PluginType.Plugin;

    // 插件API实例
    private IPluginAPI _pluginApi;

    // 生命周期方法
    public void Initialize(IPluginAPI pluginApi) 
    {
        _pluginApi = pluginApi;
        _pluginApi.Info("插件初始化完成");
    }

    public void Activate() { /* 激活插件 */ }
    public void Deactivate() { /* 停用插件 */ }
    public void Dispose() { /* 释放资源 */ }

    // UI方法
    public UserControl GetMainView() 
    {
        return new MyPluginView(); 
    }
}
```

### 4.2 2. 创建插件UI（可选）

如果插件需要UI，可以创建一个 `UserControl`：

```xaml
<UserControl x:Class="MyPlugin.MyPluginView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>
        <StackPanel>
            <TextBlock Text="我的插件" FontSize="24" FontWeight="Bold" Margin="10"/>
            <Button Content="点击我" Click="Button_Click" Margin="10"/>
        </StackPanel>
    </Grid>
</UserControl>
```

### 4.3 3. 实现插件功能

在插件类中实现具体功能，使用 `IPluginAPI` 访问工具箱服务：

```csharp
private void Button_Click(object sender, RoutedEventArgs e)
{
    // 使用文件API
    _pluginApi.WriteFileAsync("test.txt", "Hello from plugin!");
    
    // 使用日志API
    _pluginApi.Info("按钮被点击了");
}
```

### 4.4 4. 构建插件

- 构建插件项目，生成 `.dll` 文件
- 将生成的 `.dll` 文件复制到工具箱的 `Plugins` 目录

## 5. API参考

### 5.1 日志API

| 方法 | 说明 | 参数 |
|------|------|------|
| `Debug` | 记录调试信息 | message: 日志消息<br>data: 附加数据（可选） |
| `Info` | 记录普通信息 | message: 日志消息<br>data: 附加数据（可选） |
| `Warn` | 记录警告信息 | message: 日志消息<br>data: 附加数据（可选） |
| `Error` | 记录错误信息 | message: 日志消息<br>exception: 异常对象（可选） |

**示例**：
```csharp
_pluginApi.Info("插件初始化完成");
_pluginApi.Error("文件读取失败", ex);
_pluginApi.Debug($"当前时间: {DateTime.Now}");
```

### 5.2 文件操作API

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `ReadFileAsync` | 异步读取文件 | path: 文件路径 | `Task<string>` 文件内容 |
| `WriteFileAsync` | 异步写入文件 | path: 文件路径<br>content: 文件内容 | `Task` |
| `CreateFileAsync` | 异步创建文件 | path: 文件路径 | `Task` |
| `DeleteFileAsync` | 异步删除文件 | path: 文件路径 | `Task` |
| `FileExists` | 检查文件是否存在 | path: 文件路径 | `bool` 是否存在 |
| `CreateDirectoryAsync` | 异步创建目录 | path: 目录路径 | `Task` |
| `DirectoryExists` | 检查目录是否存在 | path: 目录路径 | `bool` 是否存在 |
| `SearchFiles` | 搜索文件 | directory: 目录路径<br>pattern: 搜索模式<br>recursive: 是否递归 | `IEnumerable<string>` 文件列表 |

**示例**：
```csharp
// 异步读取文件
string content = await _pluginApi.ReadFileAsync("config.json");

// 异步写入文件
await _pluginApi.WriteFileAsync("output.txt", "写入内容");

// 搜索文件
var files = _pluginApi.SearchFiles("Plugins", "*.dll", recursive: true);
```

### 5.3 窗口操作API

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `CreateWindow` | 创建新窗口 | title: 窗口标题<br>content: 窗口内容<br>isModal: 是否模态窗口 | `Window` 窗口实例 |
| `ShowWindow` | 显示窗口 | window: 窗口实例 | 无 |
| `CloseWindow` | 关闭窗口 | window: 窗口实例 | 无 |

**示例**：
```csharp
// 创建非模态窗口
var myWindow = _pluginApi.CreateWindow("我的窗口", new MyWindowView());
_pluginApi.ShowWindow(myWindow);

// 创建模态窗口
var dialogWindow = _pluginApi.CreateWindow("对话框", new DialogView(), isModal: true);
dialogWindow.ShowDialog();
```

### 5.4 插件操作API

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `GetDependency` | 获取依赖 | pluginId: 依赖ID | `IDependency` 依赖实例 |
| `HasDependency` | 检查依赖是否存在 | pluginId: 依赖ID | `bool` 是否存在 |

**示例**：
```csharp
// 检查必要依赖
if (!_pluginApi.HasDependency("RequiredDependency"))
{
    throw new Exception("缺少必要依赖");
}

// 获取依赖实例
var optionalDependency = _pluginApi.GetDependency("OptionalDependency");
if (optionalDependency != null)
{
    // 使用依赖
}
```

## 6. 生命周期管理

### 6.1 生命周期流程

1. **Initialize** → 2. **Activate** → 3. **Deactivate** → 4. **Dispose**

### 6.2 生命周期方法职责

| 方法 | 调用时机 | 职责 |
|------|----------|------|
| `Initialize` | 插件加载时 | - 获取API实例<br>- 初始化资源<br>- 注册事件<br>- 检查依赖 |
| `Activate` | 插件被选中或激活时 | - 启动插件功能<br>- 开始数据采集<br>- 显示通知 |
| `Deactivate` | 插件被取消选择或停用时 | - 暂停插件功能<br>- 停止数据采集<br>- 隐藏通知 |
| `Dispose` | 插件卸载时 | - 释放资源<br>- 关闭连接<br>- 保存状态 |

### 6.3 最佳实践

- 在 `Initialize` 中只进行必要的初始化，避免耗时操作
- 在 `Dispose` 中确保释放所有资源
- 实现 `IDisposable` 接口，正确释放非托管资源
- 使用 `using` 语句管理资源

## 7. UI开发

### 7.1 基本UI开发

插件UI开发遵循WPF标准开发流程：

1. 创建 `UserControl` XAML文件
2. 在 `GetMainView()` 方法中返回该控件实例
3. 使用MVVM模式开发复杂UI（推荐）

### 7.2 窗口创建

插件可以创建额外窗口，但必须使用工具箱提供的API：

```csharp
// 创建窗口
var window = _pluginApi.CreateWindow("我的窗口", new MyWindowView());
_pluginApi.ShowWindow(window);

// 关闭窗口
_pluginApi.CloseWindow(window);
```

### 7.3 UI最佳实践

- 使用MVVM模式开发复杂UI
- 保持UI简洁易用
- 遵循WPF设计规范
- 确保UI响应迅速，避免阻塞主线程
- 使用数据绑定而非直接操作UI控件

## 8. 依赖管理

### 8.1 依赖类型

| 类型 | 说明 | 处理方式 |
|------|------|----------|
| **必要依赖** | 插件必须依赖的组件 | 缺失时插件无法加载 |
| **非必要依赖** | 插件可选依赖的组件 | 缺失时插件仍可加载，但功能可能受限 |

### 8.2 依赖配置

依赖是否必要由插件在代码中检查：

```csharp
public void Initialize(IPluginAPI pluginApi)
{
    _pluginApi = pluginApi;
    
    // 检查必要依赖
    if (!_pluginApi.HasDependency("RequiredDependency"))
    {
        throw new Exception("缺少必要依赖: RequiredDependency");
    }
    
    // 检查可选依赖
    if (_pluginApi.HasDependency("OptionalDependency"))
    {
        var dependency = _pluginApi.GetDependency("OptionalDependency");
        // 使用可选依赖
    }
}
```

## 9. 调试和日志

### 9.1 日志记录

插件必须使用工具箱提供的日志API记录调试信息：

```csharp
// 不同级别的日志
_pluginApi.Debug("调试信息");
_pluginApi.Info("普通信息");
_pluginApi.Warn("警告信息");
_pluginApi.Error("错误信息", exception);
```

### 9.2 调试窗口

工具箱提供了专门的调试窗口，可以：
- 查看所有插件的日志信息
- 按级别筛选日志
- 清空调试信息
- 查看插件加载状态

## 10. 部署和测试

### 10.1 插件部署

1. 构建插件项目，生成 `.dll` 文件
2. 将生成的 `.dll` 文件复制到工具箱的 `Plugins` 目录
3. 启动工具箱，插件将自动加载

### 10.2 插件测试

1. **单元测试**：测试插件的核心功能
2. **集成测试**：在工具箱中测试插件的完整功能
3. **边界测试**：测试插件在各种边界条件下的表现
4. **性能测试**：测试插件的性能和资源占用

## 11. 最佳实践

### 11.1 插件设计

- **单一职责**：每个插件只负责一个功能领域
- **松耦合**：插件之间通过API交互，避免直接依赖
- **可扩展**：设计时考虑未来扩展需求
- **可测试**：便于单元测试和集成测试
- **文档完善**：提供清晰的文档和示例

### 11.2 性能优化

- 避免阻塞主线程
- 使用异步API处理耗时操作
- 合理使用资源，及时释放
- 优化UI渲染性能
- 减少不必要的计算和网络请求

### 11.3 安全性

- 遵循最小权限原则
- 验证用户输入
- 处理异常，避免崩溃
- 不访问用户敏感数据，除非得到授权
- 不修改工具箱核心文件

## 12. 示例插件

### 12.1 简单插件示例

#### 12.1.1 插件类

```csharp
public class SimplePlugin : IPlugin
{
    public string Id { get; } = "SimplePlugin";
    public string Name { get; } = "简单插件";
    public string Description { get; } = "一个简单的示例插件";
    public string Version { get; } = "1.0.0";
    public PluginType Type { get; } = PluginType.Plugin;

    private IPluginAPI _pluginApi;

    public void Initialize(IPluginAPI pluginApi)
    {
        _pluginApi = pluginApi;
        _pluginApi.Info("简单插件初始化完成");
    }

    public void Activate()
    {
        _pluginApi.Info("简单插件已激活");
    }

    public void Deactivate()
    {
        _pluginApi.Info("简单插件已停用");
    }

    public UserControl GetMainView()
    {
        return new SimplePluginView(_pluginApi);
    }

    public void Dispose()
    {
        _pluginApi.Info("简单插件已释放");
    }
}
```

#### 12.1.2 插件UI

```xaml
<UserControl x:Class="SimplePlugin.SimplePluginView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>
        <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="20">
            <TextBlock Text="简单插件示例" FontSize="24" FontWeight="Bold" TextAlignment="Center"/>
            <Button Content="点击我" Click="Button_Click" Padding="10,5" Width="150"/>
            <TextBlock x:Name="ResultText" Text="等待操作..." TextAlignment="Center"/>
        </StackPanel>
    </Grid>
</UserControl>
```

#### 12.1.3 插件UI代码

```csharp
public partial class SimplePluginView : UserControl
{
    private IPluginAPI _pluginApi;

    public SimplePluginView()
    {
        InitializeComponent();
    }

    // 通过构造函数注入API实例
    public SimplePluginView(IPluginAPI pluginApi) : this()
    {
        _pluginApi = pluginApi;
    }

    private void Button_Click(object sender, RoutedEventArgs e)
    {
        ResultText.Text = "按钮被点击了！";
        
        // 记录日志
        _pluginApi?.Info("按钮被点击");
    }
}
```

## 13. 故障排除

### 13.1 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 插件无法加载 | - 依赖缺失<br>- 代码错误<br>- 接口实现不正确 | - 检查依赖是否存在<br>- 查看调试窗口的错误信息<br>- 确保正确实现了IPlugin或IDependency接口 |
| 插件UI无法显示 | - `GetMainView()`返回null<br>- UI控件有错误 | - 确保`GetMainView()`返回有效的`UserControl`<br>- 检查UI控件的代码和XAML |
| 插件崩溃 | - 未处理异常<br>- 资源泄漏 | - 添加异常处理<br>- 正确实现`Dispose()`方法 |
| 依赖无法获取 | - 依赖ID错误<br>- 依赖未正确实现 | - 检查依赖ID是否正确<br>- 确保依赖正确实现了IDependency接口 |

### 13.2 调试方法

1. **查看调试窗口**：获取插件输出的日志信息
2. **检查事件查看器**：查看应用程序事件日志
3. **使用Visual Studio调试**：附加到工具箱进程调试插件
4. **添加详细日志**：在关键位置添加日志记录

## 14. 版本控制

### 14.1 版本号规范

使用语义化版本号（Semantic Versioning）：

```
MAJOR.MINOR.PATCH
```

- **MAJOR**：不兼容的API变更
- **MINOR**：向后兼容的功能添加
- **PATCH**：向后兼容的错误修复

### 14.2 更新策略

- 保持API向后兼容
- 更新版本号时遵循语义化版本规范
- 提供更新说明，说明变更内容
- 测试旧版本插件在新版本工具箱中的兼容性

## 15. 结语

本文档介绍了WPF插件工具箱的插件开发规范和最佳实践。遵循这些规范可以确保插件在工具箱中正常运行，提供良好的用户体验。

如果您在开发过程中遇到问题，可以查看调试窗口获取更多信息，或者联系工具箱开发者获取支持。

祝您开发愉快！

---

**WPF插件工具箱开发团队**
**创建日期：2025-12-12**